# -*- coding: utf-8 -*-
"""Pred function FISA A2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EZ53TFhwaGjXT35OK_Loc3zWKylx8YP4
"""

import numpy as np
import pandas as pd


def evaluate():
    # Input the csv file
    """
    Sample evaluation function
    Don't modify this function
    """
    df = pd.read_csv('sample_input.csv')

    actual_close = np.loadtxt('sample_close.txt')

    pred_close = predict_func(df)

    # Calculation of squared_error
    actual_close = np.array(actual_close)
    pred_close = np.array(pred_close)
    mean_square_error = np.mean(np.square(actual_close-pred_close))


    pred_prev = [df['Close'].iloc[-1]]
    pred_prev.append(pred_close[0])
    pred_curr = pred_close

    actual_prev = [df['Close'].iloc[-1]]
    actual_prev.append(actual_close[0])
    actual_curr = actual_close

    # Calculation of directional_accuracy
    pred_dir = np.array(pred_curr)-np.array(pred_prev)
    actual_dir = np.array(actual_curr)-np.array(actual_prev)
    dir_accuracy = np.mean((pred_dir*actual_dir)>0)*100

    print(f'Mean Square Error: {mean_square_error:.6f}\nDirectional Accuracy: {dir_accuracy:.1f}')

def predict_func(data):
    """
    Modify this function to predict closing prices for next 2 samples.
    Take care of null values in the sample_input.csv file which are listed as NAN in the dataframe passed to you
    Args:
        data (pandas Dataframe): contains the 50 continuous time series values for a stock index

    Returns:
        list (2 values): your prediction for closing price of next 2 samples
    """
    import torch
    from sklearn.preprocessing import MinMaxScaler
    import torch.nn as nn
    import joblib
    data = data.fillna(method='ffill')
    data_valid_close = data.reset_index()['Close']
    scaler = joblib.load('./FISA A2/scaler.gz')
    data_valid_close = scaler.transform(np.array(data_valid_close).reshape(-1,1))
    X = np.expand_dims(data_valid_close,0)
    X = torch.from_numpy(X).float()
    class LSTMmodel(nn.Module):
        def __init__(self):
            super().__init__()
            self.lstm = nn.GRU(input_size=1, hidden_size=16, num_layers=2, batch_first=True, bidirectional = True)
            self.linear1 = nn.Linear(32, 16)
            self.linear2 = nn.Linear(16, 2)
        def forward(self, x):
            x, _ = self.lstm(x)
            x = self.linear1(x[:,-1,:])
            x = self.linear2(x)
            return x
    model = LSTMmodel()
    model.load_state_dict(torch.load("./best_model_GRU_bidirectional_2linear_layer_no_skip_connection"))
    model.eval()
    with torch.no_grad():
      Y_pred = model(X)
    Y_pred_rescaled = np.squeeze(scaler.inverse_transform(Y_pred.numpy().reshape(-1,1)))
    #print(Y_pred_rescaled.tolist())

    return Y_pred_rescaled.tolist()

if __name__== "__main__":
    evaluate()